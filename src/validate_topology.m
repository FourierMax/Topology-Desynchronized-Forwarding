% MIT License
% 
% Copyright (c) [Year] [Author/Organization]

% =========================================================================
% Function: validate_topology
% Purpose: Check if the cached adjacency list matches the current links (consistency check)
% Inputs:
%   - cached_adjacency: Adjacency list loaded from cache (containers.Map)
%   - current_links: Current links generated by creat_topology_link (cell array)
% Output:
%   - is_valid: Boolean indicating consistency (true if consistent; false otherwise)
% =========================================================================
function is_valid = validate_topology(cached_adjacency, current_links)
    % Construct temporary adjacency list based on current links
    temp_adjacency = containers.Map();
    for i = 1:size(current_links,1)
        link = current_links{i,3};
        src = current_links{i,1};
        dst = current_links{i,2};
        if ~isKey(temp_adjacency, src)
            temp_adjacency(src) = containers.Map();
        end
        subMap = temp_adjacency(src);  % Get the sub-map for the source node
        subMap(dst) = 1;               % Add destination node to the sub-map
    end
    
    % Check if the number of nodes in both adjacency lists is the same
    is_valid = length(keys(cached_adjacency)) == length(keys(temp_adjacency));
    if ~is_valid, return; end
    
    % Check if each node's neighbors are consistent between cached and current
    nodes = keys(cached_adjacency);
    for i = 1:length(nodes)
        node = nodes{i};
        if ~isKey(temp_adjacency, node)
            is_valid = false;
            return;
        end
        cached_neighbors = keys(cached_adjacency(node));
        current_neighbors = keys(temp_adjacency(node));
        if ~isequal(sort(cached_neighbors), sort(current_neighbors))
            is_valid = false;
            return;
        end
    end
    is_valid = true;
end